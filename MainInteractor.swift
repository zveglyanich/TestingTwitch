//
//  MainInteractor.swift
//  TestingTwitch
//
//  Created by Pavel Zveglyanich on 7/6/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Alamofire
import RealmSwift

protocol MainBusinessLogic {
	func downloadDataModel(completion: @escaping (_ succsess: Bool, _ dataModel: [DataModel]?, _ error: Error?) -> ())
}

protocol MainDataStore {
	var dataModel: [DataModel]? { get set }
	var savedDataModel: Results<SaveData>? { get set }
}

class MainInteractor: MainBusinessLogic, MainDataStore {
	
	static let pageStep = 10

	private var page = 0
	
	var dataModel: [DataModel]?
	var savedDataModel = StorgeRealmManager.shared.realm?.objects(SaveData.self)
	
	func downloadDataModel(completion: @escaping (Bool, [DataModel]?, Error?) -> ()) {
		
		guard savedDataModel == nil || page > 0 else {
			page += 1
			return completion(true, convertDataModelFromSavedData(from: savedDataModel), nil)
		}
		let downloadingPage = (page + 1) * MainInteractor.pageStep
		NetworkManager.shared.request(MainRequest.someMain(pageNumber: downloadingPage)) { [weak self] Result in
			switch Result {
			case .success(let data):
				guard let dataModel = data else { return }
				
				if self?.dataModel == nil {
					self?.dataModel = dataModel
				} else {
					self?.dataModel?.append(contentsOf: dataModel)
				}
				self?.page = downloadingPage / MainInteractor.pageStep
				completion(true, self?.dataModel, nil)
			case .failure(let error):
				completion(false, nil, error)
			}
		}
		DispatchQueue.global(qos: .utility).async {
			self.updateValues(from: self.dataModel)
		}
	}
	
	
	
	private func updateValues(from dataModel: [DataModel]?) {
		guard let data = dataModel else { return }
		let saveArrayData: [SaveData] = data.compactMap { element in
			let saveElement = SaveData(value: [element.image,
											   element.name,
											   element.channels,
											   element.viewers])
			return saveElement
		}
		do {
			try StorgeRealmManager.shared.saveData(saveArrayData)
		} catch let error {
			print (error)
		}
	}

	private func convertDataModelFromSavedData(from dataModel: Results<SaveData>?) -> [DataModel]? {
		guard let data = dataModel else { return nil}
		let convertDataModel: [DataModel]? = data.compactMap { element in
			let convertedElement = DataModel.init(image: element.image,
												  name: element.name,
												  channels: element.channels,
												  viewers: element.viewers)
			return convertedElement
		}
		return convertDataModel
	}
}

